# 2.0 前言
“面向过程”(Procedure Oriented)是一种以过程为中心的编程思想。
C语言是面向过程的编程语言,可是依旧能够写出面向对象的程序,相同C++也当然能够写出面向过程的程序。
面向过程的编程，即将函数独立出来的优点有三：

- 1、以一连串函数调用操作代替反复编写同样的程序代码，能够使程序更易读。
- 2、能够在不同的程序中使用这些高层次抽象封装的程序。
- 3、能够依据功能和过程将项目分块，更easy将工作协作给小组team完毕。

# 2.1 如何编写函数
函数定义包含的内容(四部分)：

- 1、返回类型：即函数运行完如有须要返回给调用者的数据，其数据的数据类型
- 2、函数名：即是函数的名字。建议名字跟函数功能相关
- 3、參数列表：即是函数和调用者之间假设须要数据连接。接受调用者传递的数据。则是=须要有參数列表
- 4、函数体：即是函数的主体运行部分

# 2.2 调用函数(Invoking Function)
传值（by value）和传址（by reference）的參数传递方式。
当我们在调用一个函数时候，会在内存中建一个特殊的区域。成为“程序堆栈”。这块空间提供了每一个參数的存储空间。

堆(heap)和栈(stack)的区别：

## 预备知识：一个由C/C++编译的程序占用的内存分为以下几个部分：

- 1、栈区（stack）--- 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
- 2、堆区（heap） --- 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 
- 3、全局区（静态区）（static）全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 
未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。---程序结束后有系统释放。  
- 4、文字常量区 --- 常量字符串就是放在这里的。 程序结束后由系统释放
- 5、程序代码区 --- 存放函数体的二进制代码。

## 例子：
```c++
//main.cpp 
int a = 0;  // 全局初始化区 
char *p1;   // 全局未初始化区 
main() 
{ 
int b;  // 栈 
char s[] = "abc";  // 栈 
char *p2; // 栈 
char *p3 = "123456";  // 123456\0在常量区，p3在栈上。 
static int c =0；  // 全局（静态）初始化区 
p1 = (char *)malloc(10); 
p2 = (char *)malloc(20); 
// 分配得来的10和20字节的区域就在堆区。 
strcpy(p1, "123456"); // 123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 
} 
```

## 堆和栈的理论知识 
- 1.申请方式
stack: 
由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 
heap: 
需要程序员自己申请，并指明大小，在c中malloc函数 如p1 = (char *)malloc(10); 在C++中用new运算符 如p2 = (char *)malloc(10); 但是注意p1、p2本身是在栈中的。

- 2.申请后系统的响应
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。而且，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 

- 3.申请大小的限制
栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 

- 4.申请效率的比较
栈由系统自动分配，速度较快。但程序员是无法控制的。 
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

- 5.堆和栈中的存储内容
栈： 在函数调用时，第一个进栈的是主函数中的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。 

- 6.存取效率的比较  
char s1[] = "aaaaaaaaaaaaaaa"; 
char *s2 = "bbbbbbbbbbbbbbbbb"; 
aaaaaaaaaaa是在运行时刻赋值的； 
而bbbbbbbbbbb是在编译时就确定的； 
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 


作用域及范围

- local scope：假设定义在local scope之内，则除非显示指定初值，否则不会被初始化。
- file scope：假设定义在file scope内，必然会初始化为0。
- dynamic extent：其内存是上面所说的堆，heap memory（堆内存）。这样的内存必须有程序猿来操作。

# 2.3 提供默认参数值
void swap_refer(int &f, int *a, int *b = 3);
关于默认值的提供，有两个非常不直观的规则。

- 第一个规则，默认值的解析操作由最右边開始，假设我们提供了默认值，那么这一參数右側的全部參数都必须默认值。
- 第二个规则是默认值仅仅能指定一次，能够在函数的声明处，能够在函数定义处。可是不能在两个地方都指定。（推荐声明的时候）。

# 2.4 使用局部静态对象（using Local Static Object）
在一些须要反复计算的函数中，由于在函数的内部定义的变量集合都是局部变量。每次调用结束都会被释放，因此每次调用也都会反复计算。
可是假设为了节省函数间通信的问题而将对象定义与file scope内，则是一种冒险。由于通常file scop的对象会打乱函数间的独立性，使程序变得难以理解。
一个比較合理的解决方法便是使用局部静态对象。
和局部非静态对象不同的是，局部静态对象所处的内存空间，即使在不同的调用过程中，依旧持续存在，即是计算过的过程，不会在调用结束被释放结束。
```c++
const vector<int>*
fib_seq( int size ) {
    static vector< int > elems;
    // 函数的工作逻辑放在此处
    
    return &elems;
}
```

# 2.5 声明inline函数
关于inline函数。仅仅需要在函数前面加inline 关键字就可以。将函数声明为inline不过对编译器提出一种要求。编译器是否运行这项请求，需视编译器而定。一般而言，适合声明为inline函数的函数是：体积小，常被调用，所从事的计算并不复杂。inline函数的定义常在头文件里。因为编译器必须在它被调用的时候加以展开，所以这个时候其定义必须是有效的。

- 1.C中使用define这种形式宏定义的原因是因为，C语言是一个效率很高的语言，这种宏定义在形式及使用上像一个函数，但它使用预处理器实现，没有了参数压栈，代码生成等一系列的操作,因此，效率很高，这是它在C中被使用的一个主要原因。
- 2.这种宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。
- 3.在C++中引入了类及类的访问控制，这样，如果一个操作或者说一个表达式涉及到类的保护成员或私有成员，你就不可能使用这种宏定义来实现(因为无法将this指针放在合适的位置)。
inline 推出的目的，是为了替代C中表达式形式的宏定义，它消除了宏定义的缺点，同时又很好地继承了宏定义的优点。

# 2.6 重载运算符(Providing Overloaded Functions)
重载函数在其它的高级语言中常常见到，这个概念对大多数人来说都不默陌生。所谓的重载的函数就，事实上就是一个名字的函数，可是有多个实现的方式。
既然函数名字一样，编译器怎样知道调用的是那一个函数呢？不要忘记了之前所说的函数声明。声明包含返回类型。函数名，參数列表。借此得以让编译器检查函数调用的正确与否。因此，显然编译器通过识别參数的类型，个数类推断。
需要注意的是，编译器无法依据返回类型来推断和区分两个有同样名称和參数的函数。
为什么呢？由于我们调用的时候没有使用返回类型呀，我们仅仅是使用这个名字和參数来调用的哦。

# 2.7 定义并使用模板函数
```c++
template <typename elemType>
void display_message( const string &msg, const vector<elemType> &vec ) {
    cout << msg;
    for ( int ix = 0; ix < vec.size(); ++i) {
        elemType t = vec[ ix ];
        cout << t << ' ';
    }
}
```
关键字typename表示，elemType在display_message()函数中是一个暂时放置类型的占位符。elemType只是个任意名称，我们也可以选用foobar或T之类的名称。由于在这个例子中我们希望推迟要显示的vector的元素类型，因此把elemType放在vector的尖括号内。

如何使用function template?
```c++
vector < int > ivec;
string msg;
//...
display_message( msg, ivec );
```
编译器会将elemType绑定(bind)为int类型，然后产生一份display_message()函数实例，于是其第二个参数的类型即变成vector<int>。函数体内的局部对象的类型同样也变成了int。
elemType可以被绑定为内置类型或用户自定义类型。
一般而言，如果函数具备多种实现方式，我们可将它重载(overload)，其每份实例提供的是相同的通用服务。如果我们希望让程序代码的主体不变，仅仅改变其中用到的数据类型，可以通过function template达到目的。

当然，function template同时也可以重载函数
```c++
// function template 再经重载(overloaded)
template <typename elemType>
void display_message( const string &msg, const vector<elemType> &vec );

template <typename elemType>
void display_message( const string &msg, const list<elemType> &lt );
```

# 2.8 函数指针带来更大的弹性(Points to Functions Add Flexibility)
```c++
const vector<int> *fibon_seq( int size );
const vector<int> *lucas_seq( int size );
const vector<int> *pell_seq( int size );
const vector<int> *triang_seq( int size );
const vector<int> *square_seq( int size );
const vector<int> *pent_seq( int size );

const vector<int>* (*seq_ptr) ( int );

const vector<int>* (*seq_ptr) (int) = 0; // 我们可以给予函数指针初值。如果初值为0，表示并为指向任何函数
seq_ptr = pell_seq; // 将pell_seq()的地址赋值给seq_ptr
// 如何编写一个显示循环，在每次迭代过程中将seq_ptr设置为各个不同的数列函数(而非一一写出数列函数的名称)
const vector<int>* (*seq_array[]) ( int ) = {
    fibon_seq, lucas_seq, pell_seq,
    triang_seq, square_seq, pent_seq
}

int seq_index = 0;
while( next_seq == true ) {
    seq_ptr = seq_array[ ++seq_ptr ];
    // ...
}

enum ns_type {
    ns_fibon, ns_lucas, ns_pell,
    ns_triang, ns_square, ns_pent
};
seq_ptr = seq_array[ ns_pell ];
```

# 2.9 设定头文件
函数有一个一次定义多次声明的规则，即是在整个程序项目中，同一个函数的定义只能出现一次，可以多次声明，但是有时为了避免多次声明，可以将这样的函数声明放在头文件中。然后在每个使用该函数的程序代码中包含该头文件即可。
同时有一个例外，就是inline函数，为了能够扩展inline函数的内容，在每个调用点上，编译器都必须取得其定义，因此将其定义在头文件中是最恰当的。
同时我们需要注意函数的声明和定义的区别。
```c++
//下面的会被认为是定义而非声明
const int seq_cnt = 4;
const vector<int >* (*seq_arry[seq]) (int);
```
只要在上述定义前面加上关键字extern即可变成声明。
```c++
// OK:以下是一个声明
extern const vector<int>* (*seq_array[seq_cnt]) ( int );
```
问题：为什么seq_cnt 不需要加上关键字extern呢？
解答：const object 就和inline 函数一样，是“一次定义”规则下的例外。const object的定义只要一出文件之外便不可见。这意味着我们可以在多个程序代码文件中加以定义，不会导致任何错误。 

引用头文件的双引号("")和尖括号(<>)的差别：
双引号：此文件会被认为是一个由用户提供的头文件；搜索此文件时，会由要包含此文件的文件所在的磁盘目录开始找起，如果有，直接加载，如果没有，会到系统默认目录下寻找
尖括号：此文件被认定为标准的或者项目专属的头文件，编译器搜索此文件时，会先从某些默认的磁盘目录中寻找，如果有，直接加载，如果没有，会报错

