Node.js 应用是由三部分组成：
 1.引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。
--------------------------------------------------------------------------
        实例：var http = require("http");
--------------------------------------------------------------------------
 2.创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。
--------------------------------------------------------------------------
        var http = require('http');
        http.createServer(function (request, response) {
        	// 发送 HTTP 头部 
        	// HTTP 状态值: 200 : OK
        	// 内容类型: text/plain
        	response.writeHead(200, {'Content-Type': 'text/plain'});

        	// 发送响应数据 "Hello World"
        	response.end('Hello World\n');
        }).listen(8888);

	// 终端打印如下信息
	console.log('Server running at http://127.0.0.1:8888/');
---------------------------------------------------------------------------
 3.接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。
   接下来，打开浏览器访问 http://127.0.0.1:8888/，你会看到一个写着 "Hello World"的网页。

npm 使用：
npm install express          # 本地安装
npm install  -g  express     # 全局安装
npm list -g                  # 查看所有全局安装的模块
npm list grunt               # 查看某个模块的版本号
npm uninstall express        # 卸载模块
npm update express           # 更新模块
npm search express           # 搜索模块
==============================================================================================================
Node.js 回调函数：
 Node.js 异步编程的直接体现就是回调。
 异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。 
 回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。

 阻塞代码实例：
----------------------------------------------------------------------------
创建一个文件 input.txt ，内容如下：
     菜鸟教程官网地址：www.runoob.com
创建 main.js 文件, 代码如下：

     var fs = require("fs");

     var data = fs.readFileSync('input.txt');

     console.log(data.toString());
     console.log("程序执行结束!");


 非阻塞代码实例：
----------------------------------------------------------------------------
创建一个文件 input.txt ，内容如下：

菜鸟教程官网地址：www.runoob.com
创建 main.js 文件, 代码如下：

var fs = require("fs");

fs.readFile('input.txt', function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});

console.log("程序执行结束!");

以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行完程序。 
第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。
因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。


===============================================================================================================
Node.js 事件循环：

Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。
Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。
Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。
Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.

Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：

// 引入 events 模块
var events = require('events');
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();
以下程序绑定事件处理程序：

// 绑定事件及事件的处理程序
eventEmitter.on('eventName', eventHandler);
我们可以通过程序触发事件：

// 触发事件
eventEmitter.emit('eventName');

实例：
创建 main.js 文件，代码如下所示：
----------------------------------------------------------------------------------------------------
// 引入 events 模块
var events = require('events');

// 创建eventEmitter 对象
var eventEmitter = new events.EventEmitter();

// 创建事件处理程序
var connectHandler = function connected() {
    console.log("连接成功！");

    eventEmitter.emit('data_received');
}

// 绑定connection事件处理程序
eventEmitter.on('connection',connectHandler);

// 使用匿名函数绑定 data_received事件
eventEmitter.on('data_received',function(){
    console.log("数据接收成功！");
});


// 触发connection事件
eventEmitter.emit('connection');

console.log("程序执行完毕!");


在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。
-----------------------------------------------------------------------------------------------------
var fs = require("fs");

fs.readFile('input.txt', function (err, data) {
   if (err){
      console.log(err.stack);
      return;
   }
   console.log(data.toString());
});
console.log("程序执行完毕");
以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。
如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。

事件就是需要 eventEmitter.on 去绑定一个事件,通过 eventEmitter.emit 去触发这个事件。
其次说的是事件的接收和发生是分开的，就像 一个外卖店你可以不停的接受很多订单, 接受以后开始告诉厨师去做外卖, 
做好的外卖对应的外送给每个用户，如果单线程的话那只能是接收一个订单, 做好以后在接收下一个外卖订单，明显效率非常低。
事件可以不停的接受不停的发生也是为了提高效率。

===============================================================================================================
Node.js EventEmitter：
Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。
Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件，一个fs.readStream对象会在文件被打开的时候发出一个事件。 
所有这些产生事件的对象都是 events.EventEmitter 的实例。
EventEmitter 类
events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。
你可以通过require("events");来访问该模块。
// 引入 events 模块
var events = require('events');
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();
EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。
下面我们用一个简单的例子说明 EventEmitter 的用法：
-------------------------------------------------------------------
//event.js 文件
var EventEmitter = require('events').EventEmitter; 
var event = new EventEmitter(); 
event.on('some_event', function() { 
    console.log('some_event 事件触发'); 
}); 
setTimeout(function() { 
    event.emit('some_event'); 
}, 1000); 

执行结果如下：
运行这段代码，1 秒后控制台输出了 'some_event 事件触发'。其原理是 event 对象注册了事件 some_event 的一个监听器，
然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。

EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。
对于每个事件，EventEmitter 支持 若干个事件监听器。
当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。
-------------------------------------------------------------------
//event.js 文件
var events = require('events'); 
var emitter = new events.EventEmitter(); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener1', arg1, arg2); 
}); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener2', arg1, arg2); 
}); 
emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); 

方法：

序号	                    方法 & 描述
------------         ------------------------------------------------------------------------
1	             addListener(event, listener) 为指定事件添加一个监听器到监听器数组的尾部。

2	             on(event, listener)为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。
                       server.on('connection', function (stream) {
                          console.log('someone connected!');
                       });

3	             once(event, listener)为指定事件注册一个单次监听器，即 监听器最多只会触发一次，
                     触发后立刻解除该监听器。
                     server.once('connection', function (stream) {
                          console.log('Ah, we have our first user!');
                       });

4	             removeListener(event, listener)
                     移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。
                     它接受两个参数，第一个是事件名称，第二个是回调函数名称。

                     var callback = function(stream) {
                          console.log('someone connected!');
                       };
                     server.on('connection', callback);
                     // ...
                     server.removeListener('connection', callback);

5	             removeAllListeners([event])
                     移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。

6	             setMaxListeners(n)
                     默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 
                     setMaxListeners 函数用于提高监听器的默认限制的数量。

7	             listeners(event)
                     返回指定事件的监听器数组。

8	             emit(event, [arg1], [arg2], [...])
                     按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。

类方法：

1	             listenerCount(emitter, event)
                     返回指定事件的监听器数量。


事件：
1	             newListener
                       event - 字符串，事件名称
                       listener - 处理事件函数
                     该事件在添加新监听器时被触发。

2	             removeListener
                       event - 字符串，事件名称
                       listener - 处理事件函数
                       从指定监听器数组中删除一个监听器。
                       需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。


实例：
以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。
创建 main.js 文件，代码如下：
-----------------------------------------------------------------------------------
var events = require('events');
var eventEmitter = new events.EventEmitter();

// 监听器 #1
var listener1 = function listener1() {
   console.log('监听器 listener1 执行。');
}

// 监听器 #2
var listener2 = function listener2() {
  console.log('监听器 listener2 执行。');
}

// 绑定 connection 事件，处理函数为 listener1 
eventEmitter.addListener('connection', listener1);

// 绑定 connection 事件，处理函数为 listener2
eventEmitter.on('connection', listener2);

var eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');
console.log(eventListeners + " 个监听器监听连接事件。");

// 处理 connection 事件 
eventEmitter.emit('connection');

// 移除监绑定的 listener1 函数
eventEmitter.removeListener('connection', listener1);
console.log("listener1 不再受监听。");

// 触发连接事件
eventEmitter.emit('connection');

eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');
console.log(eventListeners + " 个监听器监听连接事件。");

console.log("程序执行完毕。");

error事件：
EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。
当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。
我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。

继承 EventEmitter：
大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。
包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。
为什么要这样做呢？原因有两点：
首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。
其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。


===============================================================================================================
Node.js Buffer（缓冲区）：
JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。
但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。
在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，
每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，
但它对应于 V8 堆内存之外的一块原始内存。

Buffer 与字符编码：
const buf = Buffer.from('runoob', 'ascii');
// 输出 72756e6f6f62
console.log(buf.toString('hex'));
// 输出 cnVub29i
console.log(buf.toString('base64'));

node.js目前支持的字符编码包括：
ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。
utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。
utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。
ucs2 - utf16le 的别名。
base64 - Base64 编码。
latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。
binary - latin1 的别名。
hex - 将每个字节编码为两个十六进制字符。

创建 Buffer 类：
Buffer 提供了以下 API 来创建 Buffer 类：
Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0
Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据
Buffer.allocUnsafeSlow(size)
Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）
Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。
Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例
Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例

-------------------------------------------------------------------------------------------
// 创建一个长度为 10、且用 0 填充的 Buffer。
const buf1 = Buffer.alloc(10);

// 创建一个长度为 10、且用 0x1 填充的 Buffer。 
const buf2 = Buffer.alloc(10, 1);

// 创建一个长度为 10、且未初始化的 Buffer。
// 这个方法比调用 Buffer.alloc() 更快，
// 但返回的 Buffer 实例可能包含旧数据，
// 因此需要使用 fill() 或 write() 重写。
const buf3 = Buffer.allocUnsafe(10);

// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。
const buf4 = Buffer.from([1, 2, 3]);

// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。
const buf5 = Buffer.from('tést');

// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。
const buf6 = Buffer.from('tést', 'latin1');


写入缓冲区：
写入 Node 缓冲区的语法如下所示：
buf.write(string[, offset[, length]][, encoding])
参数描述如下：

string - 写入缓冲区的字符串。
offset - 缓冲区开始写入的索引值，默认为 0 。
length - 写入的字节数，默认为 buffer.length
encoding - 使用的编码。默认为 'utf8' 。

根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 
如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。

返回值是返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。


从缓冲区读取数据：
读取 Node 缓冲区数据的语法如下所示：
buf.toString([encoding[, start[, end]]])
参数描述如下：
encoding - 使用的编码。默认为 'utf8' 。
start - 指定开始读取的索引位置，默认为 0。
end - 结束位置，默认为缓冲区的末尾。

返回值是解码缓冲区数据并使用指定的编码返回字符串。
------------------------------------------------------------------
buf = Buffer.alloc(26);
for (var i = 0 ; i < 26 ; i++) {
  buf[i] = i + 97;
}
console.log( buf.toString('ascii'));       // 输出: abcdefghijklmnopqrstuvwxyz
console.log( buf.toString('ascii',0,5));   // 输出: abcde
console.log( buf.toString('utf8',0,5));    // 输出: abcde
console.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde


将Buffer转换为 JSON 对象
语法：
将 Node Buffer 转换为 JSON 对象的函数语法格式如下：
   buf.toJSON()
当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。
返回值：返回 JSON 对象。
------------------------------------------------------------------
const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
const json = JSON.stringify(buf);

// 输出: {"type":"Buffer","data":[1,2,3,4,5]}
console.log(json);

const copy = JSON.parse(json, (key, value) => {
  return value && value.type === 'Buffer' ?
    Buffer.from(value.data) :
    value;
});

// 输出: <Buffer 01 02 03 04 05>
console.log(copy);


缓冲区合并
Node 缓冲区合并的语法如下所示：
Buffer.concat(list[, totalLength])

参数：
 参数描述如下：
 list - 用于合并的 Buffer 对象数组列表。
 totalLength - 指定合并后Buffer对象的总长度。

 返回值：
 返回一个多个成员合并的新 Buffer 对象。
--------------------------------------------------------------------
var buffer1 = Buffer.from(('菜鸟教程'));
var buffer2 = Buffer.from(('www.runoob.com'));
var buffer3 = Buffer.concat([buffer1,buffer2]);
console.log("buffer3 内容: " + buffer3.toString());


缓冲区比较
语法：
 Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：
 buf.compare(otherBuffer);
参数：
 参数描述如下：
 otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。
返回值
 返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。
---------------------------------------------------------------------
var buffer1 = Buffer.from('ABC');
var buffer2 = Buffer.from('ABCD');
var result = buffer1.compare(buffer2);

if(result < 0) {
   console.log(buffer1 + " 在 " + buffer2 + "之前");
}else if(result == 0){
   console.log(buffer1 + " 与 " + buffer2 + "相同");
}else {
   console.log(buffer1 + " 在 " + buffer2 + "之后");
}


拷贝缓冲区
语法
Node 缓冲区拷贝语法如下所示：

buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])
参数
 参数描述如下：
 targetBuffer - 要拷贝的 Buffer 对象。
 targetStart - 数字, 可选, 默认: 0
 sourceStart - 数字, 可选, 默认: 0
 sourceEnd - 数字, 可选, 默认: buffer.length

 返回值:没有返回值。
----------------------------------------------------------------------
var buf1 = Buffer.from('abcdefghijkl');
var buf2 = Buffer.from('RUNOOB');

//将 buf2 插入到 buf1 指定位置上
buf2.copy(buf1, 2);

console.log(buf1.toString());


缓冲区裁剪
Node 缓冲区裁剪语法如下所示：
buf.slice([start[, end]])
参数：
 参数描述如下：
 start - 数字, 可选, 默认: 0
 end - 数字, 可选, 默认: buffer.length
返回值：返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。
----------------------------------------------------------------------
var buffer1 = Buffer.from('runoob');
// 剪切缓冲区
var buffer2 = buffer1.slice(0,2);
console.log("buffer2 content: " + buffer2.toString());

缓冲区长度
语法：Node 缓冲区长度计算语法如下所示
 buf.length;
返回值：返回 Buffer 对象所占据的内存长度。
----------------------------------------------------------------------
var buffer = Buffer.from('www.runoob.com');
//  缓冲区长度
console.log("buffer length: " + buffer.length);

*********************************************************************************************
方法参考手册：
以下列出了 Node.js Buffer 模块常用的方法（注意有些方法在旧版本是没有的）：

              序号	                                                                                             方法 & 描述
---------------------------------                   --------------------------------------------------------------------------------------------------------------------------
1	                                            new Buffer(size) 
                                                    分配一个新的 size 大小单位为8位字节的 buffer。 

2	                                            new Buffer(buffer) 
                                                    拷贝参数 buffer 的数据到 Buffer 实例。

3	                                            new Buffer(str[, encoding])
                                                    分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 'utf8'。 

4	                                            buf.length
                                                    返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。
                                                    length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。

5	                                            buf.write(string[, offset[, length]][, encoding])
                                                    根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string 数据写入buffer。 
                                                    offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length 长度是将要写入的字符串的 bytes 大小。 
                                                    返回 number 类型，表示写入了多少 8 位字节流。如果 buffer 没有足够的空间来放整个 string，它将只会只写入部分字符串。 
                                                    length 默认是 buffer.length - offset。 这个方法不会出现写入部分字符。

6	                                            buf.writeUIntLE(value, offset, byteLength[, noAssert])
                                                    将 value 写入到 buffer 里， 它由 offset 和 byteLength 决定，最高支持 48 位无符号整数，小端对齐，例如：
                                                    const buf = Buffer.allocUnsafe(6);
                                                    buf.writeUIntLE(0x1234567890ab, 0, 6);
                                                    // 输出: <Buffer ab 90 78 56 34 12>
                                                    console.log(buf); 
                                                    noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。

7	                                            buf.writeUIntBE(value, offset, byteLength[, noAssert])
                                                    将 value 写入到 buffer 里， 它由 offset 和 byteLength 决定，最高支持 48 位无符号整数，大端对齐。
                                                    noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。
                                                    const buf = Buffer.allocUnsafe(6);
                                                    buf.writeUIntBE(0x1234567890ab, 0, 6);
                                                    // 输出: <Buffer 12 34 56 78 90 ab>
                                                    console.log(buf);

8	                                            buf.writeIntLE(value, offset, byteLength[, noAssert])
                                                    将value 写入到 buffer 里， 它由offset 和 byteLength 决定，最高支持48位有符号整数，小端对齐。
                                                    noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。

9	                                            buf.writeIntBE(value, offset, byteLength[, noAssert])
                                                    将value 写入到 buffer 里， 它由offset 和 byteLength 决定，最高支持48位有符号整数，大端对齐。
                                                    noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。

10	                                            buf.readUIntLE(offset, byteLength[, noAssert])
                                                    支持读取 48 位以下的无符号数字，小端对齐。
                                                    noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。

11	                                            buf.readUIntBE(offset, byteLength[, noAssert])
                                                    支持读取 48 位以下的无符号数字，大端对齐。
                                                    noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。

12	                                            buf.readIntLE(offset, byteLength[, noAssert])
                                                    支持读取 48 位以下的有符号数字，小端对齐。
                                                    noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。

13	                                            buf.readIntBE(offset, byteLength[, noAssert])
                                                    支持读取 48 位以下的有符号数字，大端对齐。
                                                    noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。
 
14	                                            buf.toString([encoding[, start[, end]]])
                                                    根据 encoding 参数（默认是 'utf8'）返回一个解码过的 string 类型。
                                                    还会根据传入的参数 start (默认是 0) 和 end (默认是 buffer.length)作为取值范围。

15	                                            buf.toJSON()
                                                    将 Buffer 实例转换为 JSON 对象。

16	                                            buf[index]
                                                    获取或设置指定的字节。
                                                    返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。
 
17	                                            buf.equals(otherBuffer)
                                                    比较两个缓冲区是否相等，如果是返回 true，否则返回 false。

18	                                            buf.compare(otherBuffer)
                                                    比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。

19	                                            buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])
                                                    buffer 拷贝，源和目标可以相同。 
                                                    targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 
                                                    sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。

20	                                            buf.slice([start[, end]])
                                                    剪切 Buffer 对象，根据 start(默认是 0 ) 和 end (默认是 buffer.length ) 偏移和裁剪了索引。 
                                                    负的索引是从 buffer 尾部开始计算的。

21	                                            buf.readUInt8(offset[, noAssert])
                                                    根据指定的偏移量，读取一个无符号 8 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 
                                                    如果这样 offset 可能会超出buffer 的末尾。默认是 false。

22	                                            buf.readUInt16LE(offset[, noAssert])
                                                    根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数。
                                                    若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。

23	                                            buf.readUInt16BE(offset[, noAssert])
                                                    根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数，大端对齐。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 
                                                    这意味着 offset 可能会超出 buffer 的末尾。默认是 false。

24	                                            buf.readUInt32LE(offset[, noAssert])
                                                    根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 
                                                    这意味着 offset 可能会超出buffer 的末尾。默认是 false。

25	                                            buf.readUInt32BE(offset[, noAssert])
                                                    根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，大端对齐。 
                                                    若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。

26	                                            buf.readInt8(offset[, noAssert])
                                                    根据指定的偏移量，读取一个有符号 8 位整数。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 
                                                    这意味着 offset 可能会超出 buffer 的末尾。默认是 false。

27	                                            buf.readInt16LE(offset[, noAssert])
                                                    根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 
                                                    这意味着 offset 可能会超出 buffer 的末尾。默认是 false。

28	                                            buf.readInt16BE(offset[, noAssert])
                                                    根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，大端对齐。 
                                                    若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。

29	                                            buf.readInt32LE(offset[, noAssert])
                                                    根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 
                                                    这意味着 offset 可能会超出buffer 的末尾。默认是 false。

30	                                            buf.readInt32BE(offset[, noAssert])
                                                    根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 
                                                    这意味着 offset 可能会超出buffer 的末尾。默认是 false。

31	                                            buf.readFloatLE(offset[, noAssert])
                                                    根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位双浮点数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 
                                                    这意味着 offset 可能会超出buffer的末尾。默认是 false。

32	                                            buf.readFloatBE(offset[, noAssert])
                                                    根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位双浮点数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 
                                                    这意味着 offset 可能会超出buffer的末尾。默认是 false。

33	                                            buf.readDoubleLE(offset[, noAssert])
                                                    根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位双精度数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 
                                                    这意味着 offset 可能会超出buffer 的末尾。默认是 false。

34	                                            buf.readDoubleBE(offset[, noAssert])
                                                    根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位双精度数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 
                                                    这意味着 offset 可能会超出buffer 的末尾。默认是 false。

35	                                            buf.writeUInt8(value, offset[, noAssert])
                                                    根据传入的 offset 偏移量将 value 写入 buffer。注意：value 必须是一个合法的无符号 8 位整数。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 
                                                    这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则不要使用。默认是 false。

36	                                            buf.writeUInt16LE(value, offset[, noAssert])
                                                    根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 
                                                    这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。

37	                                            buf.writeUInt16BE(value, offset[, noAssert])
                                                    根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 
                                                    这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。

38	                                            buf.writeUInt32LE(value, offset[, noAssert])
                                                    根据传入的 offset 偏移量和指定的 endian 格式(LITTLE-ENDIAN:小字节序)将 value 写入buffer。注意：value 必须是一个合法的无符号 32 位整数，小端对齐。 
                                                    若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 
                                                    这意味着value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。

39	                                            buf.writeUInt32BE(value, offset[, noAssert])
                                                    根据传入的 offset 偏移量和指定的 endian 格式(Big-Endian:大字节序)将 value 写入buffer。注意：value 必须是一个合法的有符号 32 位整数。 
                                                    若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 
                                                    除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。

40	                                            buf.writeInt8(value, offset[, noAssert])

41	                                            buf.writeInt16LE(value, offset[, noAssert])
                                                    根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 
                                                    这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。

42	                                            buf.writeInt16BE(value, offset[, noAssert])
                                                    根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 
                                                    这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。

43	                                            buf.writeInt32LE(value, offset[, noAssert])
                                                    根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 
                                                    这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。

44	                                            buf.writeInt32BE(value, offset[, noAssert])
                                                    根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 
                                                    这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。

45	                                            buf.writeFloatLE(value, offset[, noAssert])
                                                    根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 
                                                    这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。

46	                                            buf.writeFloatBE(value, offset[, noAssert])
                                                    根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 
                                                    这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。

47	                                            buf.writeDoubleLE(value, offset[, noAssert])
                                                    根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 
                                                    这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。

48	                                            buf.writeDoubleBE(value, offset[, noAssert])
                                                    根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 
                                                    这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。

49	                                            buf.fill(value[, offset][, end])
                                                    使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。


===============================================================================================================
Node.js Stream（流）：
Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。
Node.js，Stream 有四种流类型：
Readable - 可读操作。
Writable - 可写操作。
Duplex - 可读可写操作.
Transform - 操作被写入数据，然后读出结果。

所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：
data - 当有数据可读时触发。
end - 没有更多的数据可读时触发。
error - 在接收和写入过程中发生错误时触发。
finish - 所有数据已被写入到底层系统时触发。


从流中读取数据

创建 input.txt 文件，内容如下：
菜鸟教程官网地址：www.runoob.com
---------------------------------------------------------------------------
var fs = require("fs");
var data ='';

// 创建可读流
var readerStream = fs.createReadStream('input.txt');

// 设置编码为utf8
readerStream.setEncoding('utf8');

// 处理流事件 --> data, end, and error
readerStream.on('data', function(chunk) {
    data += chunk;
 });

 readerStream.on('end',function(){
    console.log(data);
 });

 readerStream.on('error', function(err){
    console.log(err.stack);
 });

 console.log("程序执行完毕");
 

写入流
创建 main.js 文件, 代码如下：
---------------------------------------------------------------------------
var fs = require("fs");
var data = '菜鸟教程官网地址：www.runoob.com';

// 创建一个可以写入的流，写入到文件 output.txt 中
var writerStream = fs.createWriteStream('output.txt');

// 使用 utf8 编码写入数据
writerStream.write(data,'UTF8');

// 标记文件末尾
writerStream.end();

// 处理流事件 --> data, end, and error
writerStream.on('finish', function() {
    console.log("写入完成。");
});

writerStream.on('error', function(err){
   console.log(err.stack);
});

console.log("程序执行完毕");


管道流
管道提供了一个输出流到输入流的机制。
通常我们用于从一个流中获取数据并将数据传递到另外一个流中。
----------------------------------------------------------------------------
var fs = require("fs");

// 创建一个可读流
var readerStream = fs.createReadStream('input.txt');

// 创建一个可写流
var writerStream = fs.createWriteStream('output.txt');

// 管道读写操作
// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中
readerStream.pipe(writerStream);

console.log("程序执行完毕");



链式流
链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。
接下来我们就是用管道和链式来压缩和解压文件。
压缩：
-----------------------------------------------------------------------------
var fs = require("fs");
var zlib = require('zlib');

// 压缩 input.txt 文件为 input.txt.gz
fs.createReadStream('input.txt')
  .pipe(zlib.createGzip())
  .pipe(fs.createWriteStream('input.txt.gz'));
  
console.log("文件压缩完成。");

解压：
-----------------------------------------------------------------------------
var fs = require("fs");
var zlib = require('zlib');

// 解压 input.txt.gz 文件为 input.txt
fs.createReadStream('input.txt.gz')
  .pipe(zlib.createGunzip())
  .pipe(fs.createWriteStream('input.txt'));
  
console.log("文件解压完成。");


===============================================================================================================
Node.js 模块系统：
为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。
模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。

创建模块：
在 Node.js 中，创建一个模块非常简单，如下我们创建一个 main.js 文件，代码如下:
var hello = require('./hello');
hello.world();
以上实例中，代码 require('./hello') 引入了当前目录下的 hello.js 文件（./ 为当前目录，node.js 默认后缀为 js）。
Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。
接下来我们就来创建 hello.js 文件，代码如下：
exports.world = function() {
  console.log('Hello World');
}
在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require('./hello') 加载这个模块，
然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。
有时候我们只是想把一个对象封装到模块中，格式如下：
module.exports = function() {
  // ...
}

例如:

//hello.js 
function Hello() { 
    var name; 
    this.setName = function(thyName) { 
        name = thyName; 
    }; 
    this.sayHello = function() { 
        console.log('Hello ' + name); 
    }; 
}; 
module.exports = Hello;
这样就可以直接获得这个对象了：

//main.js 
var Hello = require('./hello'); 
hello = new Hello(); 
hello.setName('BYVoid'); 
hello.sayHello(); 
模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 
在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。

Node.js 的 require 方法中的文件查找策略
Node.js 中存在 4 类模块（原生模块和3种文件模块）
在路径 Y 下执行 require(X) 语句执行顺序：
-------------------------------------------------------------------------------------
1. 如果 X 是内置模块
   a. 返回内置模块
   b. 停止执行
2. 如果 X 以 '/' 开头
   a. 设置 Y 为文件根路径
3. 如果 X 以 './' 或 '/' or '../' 开头
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
4. LOAD_NODE_MODULES(X, dirname(Y))
5. 抛出异常 "not found"

LOAD_AS_FILE(X)
1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。
2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。
3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。
4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。

LOAD_INDEX(X)
1. 如果 X/index.js 是一个文件,  将 X/index.js 作为 JavaScript 文本载入并停止执行。
2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。
3. 如果 X/index.node 是一个文件,  将 X/index.node 作为二进制插件载入并停止执行。

LOAD_AS_DIRECTORY(X)
1. 如果 X/package.json 是一个文件,
   a. 解析 X/package.json, 并查找 "main" 字段。
   b. let M = X + (json main 字段)
   c. LOAD_AS_FILE(M)
   d. LOAD_INDEX(M)
2. LOAD_INDEX(X)

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let I = count of PARTS - 1
3. let DIRS = []
4. while I >= 0,
   a. if PARTS[I] = "node_modules" CONTINUE
   b. DIR = path join(PARTS[0 .. I] + "node_modules")
   c. DIRS = DIRS + DIR
   d. let I = I - 1
5. return DIRS
-------------------------------------------------------------------------------------


===============================================================================================================
Node.js 函数：
在JavaScript中，一个函数可以作为另一个函数的参数。
我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。
Node.js中函数的使用与Javascript类似，举例来说，你可以这样做：
function say(word) {
  console.log(word);
}

function execute(someFunction, value) {
  someFunction(value);
}

execute(say, "Hello");
以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里返回的不是 say 的返回值，而是 say 本身！
这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。
当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。

匿名函数
function execute(someFunction, value) {
  someFunction(value);
}

execute(function(word){ console.log(word) }, "Hello");
我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。
用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。

函数传递是如何让HTTP服务器工作的？
var http = require("http");

http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Hello World");
  response.end();
}).listen(8888);

我们向 createServer 函数传递了一个匿名函数。
用这样的代码也可以达到同样的目的：
var http = require("http");
function onRequest(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Hello World");
  response.end();
}
http.createServer(onRequest).listen(8888);


===============================================================================================================
Node.js 路由：
我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。
因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET/POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，
但这里暂定其为我们的HTTP服务器的功能。我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。
但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。
                   url.parse(string).query
                                           |
           url.parse(string).pathname      |
                       |                   |
                       |                   |
                     ------ -------------------
http://localhost:8888/start?foo=bar&hello=world
                                ---       -----
                                 |          |
                                 |          |
              querystring.parse(queryString)["foo"]    |
                                            |
                         querystring.parse(queryString)["hello"]














===========================================================================================================
promise基本概念
 promise只有三种状态，未完成，完成(fulfilled)和失败(rejected)。
 promise的状态可以由未完成转换成完成，或者未完成转换成失败。
 promise的状态转换只发生一次

promise有一个then方法，then方法可以接受3个函数作为参数。前两个函数对应promise的两种状态fulfilled, rejected的回调函数。第三个函数用于处理进度信息。

promiseSomething().then(function(fulfilled){
        //当promise状态变成fulfilled时，调用此函数
    },function(rejected){
        //当promise状态变成rejected时，调用此函数
    },function(progress){
        //当返回进度信息时，调用此函数
    });

























